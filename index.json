[{"content":"We distribute an RPM or Docker container for the Provisioner package. Debian is not supported at present.\nYUM Repository For RPMs we publish releases but also nightly builds to our repositories.\nUsers of our Puppet modules will already have these repositories available.\nRelease [choria_release] name=Choria Orchestrator Releases mirrorlist=http://mirrorlists.choria.io/yum/release/el/$releasever/$basearch.txt enabled=True gpgcheck=True repo_gpgcheck=True gpgkey=https://choria.io/RELEASE-GPG-KEY metadata_expire=300 sslcacert=/etc/pki/tls/certs/ca-bundle.crt sslverify=True Nightly Nightly releases are named and versioned choria-provisioner-0.99.0.20221109-1.el7.x86_64.rpm where the last part of the version is the date.\n[choria_nightly] name=Choria Orchestrator Nightly mirrorlist=http://mirrorlists.choria.io//yum/nightly/el/$releasever/$basearch.txt enabled=True gpgcheck=True repo_gpgcheck=True gpgkey=https://choria.io/NIGHTLY-GPG-KEY metadata_expire=300 sslcacert=/etc/pki/tls/certs/ca-bundle.crt sslverify=True Docker There is a docker container choria-io/provisioner that has releases only.\n","description":"","tags":null,"title":"Installation","uri":"/installtion/index.html"},{"content":"The Choria Server has the required RPC Agent embedded and is ready to be used in a Provisioner managed network but it is disabled by default. Custom binaries can enable provisioning at compile time for an always-on experience.\nProvisioning is enabled in the Open Source server by means of a JWT token that you create and place on the server. The JWT token holds all of the information the server needs to find it’s provisioning server and will present that token also to the provisioning server for authentication.\nThe token is signed using a trusted private key, the provisioner will only provision nodes presenting a trusted key.\nCredentials If you are using a x509 based setup you really just need any RSA Key pair to sign the JWT with:\n$ openssl genrsa -out provisioning-jwt-signer-key.pem 2048 $ openssl rsa -in provisioning-jwt-signer-key.pem -outform PEM -pubout -out provisioning-jwt-signer.pem The public file will be placed on all your brokers to enable provisioning.\nFor the Organization Issuer based deploys you would sign it using your Issuer.\nCreating the JWT Choria JWTs are creating using the choria jwt command, for provisioning specifically choria jwt provisioning.\nCreating the JWT:\n$ choria jwt provisioning.jwt provisioning-jwt-signer-key.pem --srv choria.example.net --token toomanysecrets Saved token to provisioning.jwt, use 'choria jwt view provisioning.jwt' to view it $ choria jwt provisioning.jwt Unvalidated Provisioning Token x.jwt Token: ***** Secure: true SRV Domain: choria.example.net Provisioning by default: false Standard Claims: { \"purpose\": \"choria_provisioning\", \"iss\": \"Choria Tokens Package v0.26.2\", \"sub\": \"choria_provisioning\", \"nbf\": 1669805752, \"iat\": 1669805752, \"jti\": \"2c99227346f641bbba34faf0a6991d05\" } Here we create a provisioning.jwt that will instruct Choria to look for _choria-provisioner._tcp.choria.example.net SRV records to find the server to connect to.\nOther options can be set for example to hard code provisioning URLs, username and passwords and more.\n Version Hint This table is correct for Choria 0.27.0 and newer which is due to ship early 2023. Review --help for your version.\n     Option Description Default Required     signing-key The token must be signed using a private key, this can be a file with either RSA or ed25519 private key.  yes   --[no]-insecure During provisioning the protocol security system cannot be active as no private credentials exist, this disables that since 0.27.0 no   --token A basic shared secret that the provisioner must present to perform certain actions  no   --urls A static, comma seperated, list of servers to connect to for provisioning  no   --srv A domain name to query for SRV records  no   --default Enables provisioning by default. Else requires plugin.choria.server.provision to be set false no   --registration Path to a file to publish as registration data while in provisioning mode  no   --facts Path to a file to use as fact source data while in provisioning mode  no   --username A NATS user to use when connecting to the broker  no   --password Password to use when connecting to the broker  no   --extensions Additional free-form data to embed in the JWT as JSON text  no   --org The Organization this server belongs to choria yes   --vault Use Hashicorp Vault for signing the token, the signing-key is then the name of the vault key false no   --protocol-v2 Enables the choria security system and version 2 protocol. Set for Org Issuer based networks false no    When this file is placed in /etc/choria/provisioning.jwt and Choria starts without a configuration it will provision via these settings.\nChoria also support provisioning plugins to resolve this information dynamically but this requires custom binaries and should in general be avoided.\nConfirming Without the JWT in place Provisioning is not enabled:\n$ choria buildinfo ... Server Settings: Provisioning Target Resolver: Choria JWT Resolver Supports Provisioning: false Provisioning JWT file: /etc/choria/provisioning.jwt ... We can see it will look for the /etc/choria/provisioning.jwt file, lets move our newly created file there and try again:\n$ sudo msg provisioning.jwt /etc/choria/provisioning.jwt $ choria buildinfo ... Server Settings: Provisioning Target Resolver: Choria JWT Resolver Supports Provisioning: true Provisioning JWT file: /etc/choria/provisioning.jwt Provisioning Token: ***** Provisioning Default: false Provisioning TLS: true Default Provisioning Agent: true Provisioning SRV Domain: choria.example.net ... Now provisioning is on with the settings we provided in the token.\n","description":"","tags":null,"title":"Server Setup","uri":"/configuration/server/index.html"},{"content":"Choria Broker supports a concept called an Account or Organization, these are like a VLAN on your network switches.\nNodes partitioned into one Organization cannot communicate with nodes in any other Organizations unless special arrangements are made to facilitate that.\nWe use this feature to create an isolated network where unprovisioned servers wait for provisioning. When Choria Provisioner connects using fully verified credentials it gains access to these isolated Servers and can provision them.\n \nHere we show one Choria Broker Cluster with a Choria Account and a Provisioning Account active. Unverified connections enter the Provisioning Account automatically. The Provisioner connects with its fully verified credentials that identify it as a Provisioner and gains access to the unprovisioned servers.\nRestrictions in the Choria Broker authentication layer ensures this separation is not optional and enforce control over what software gains access to the unprovisioned fleet.\nEnabling the System Account We suggest enabling the Choria Broker system account to allow introspection of nodes waiting to be provisioned and more.\nConfigure this in both your Broker and Client configurations.\nplugin.choria.network.system.user = system plugin.choria.network.system.password = system Enabling the Provisioning Account The Choria Provisioner will connect using its normal Certificate or JWT token which means it will appear just like any other client. To differentiate it we force it to connect to a specific user and password.\nThe password is unique per environment and should be configured in the broker:\nplugin.choria.network.provisioning.client_password = provSecret x509 Based Choria If you are using an x509 based network you have to set the Public certificate that was used to configure servers.\nplugin.choria.network.provisioning.signer_cert = /etc/choria/provisioning-jwt-signer.pem Organization Based Choria  Version Hint This applies only to Choria 0.27.0 and newer which is due to ship early 2023\n  If you are using an Organization Issuer you should already have the issuer configured and have used that issuer to sign the provisioning.jwt\nplugin.security.issuer.names = choria plugin.security.issuer.choria.public = 4ada2...cea4 Confirming Once configured you can run the command choria broker server report conns --account provisioning to both confirm the account is active and it will show any connections made to this account. The Choria Provisioner will appear there as well as any machines being provisioned.\n \n","description":"","tags":null,"title":"Broker Setup","uri":"/configuration/broker/index.html"},{"content":"Configuring the Provisioner requires exact knowledge of your deployment needs, we suggest you start with first configuring servers by hand while exploring your needs, once the specific configuration file contents and security needs are defined those can be configured into the Provisioner system.\nDeploying a Provisioner should not be the first thing you do.\nGeneral Requirements Choria Broker You must be running the Choria Broker and it will need a few extra configuration items.\nJWT files or custom binaries You can enable Provisioning mode in the standard Open Source Choria Server by placing a provisining.jwt in the right place. Those doing custom builds can also apply build-time defaults that has no external dependencies.\nHelper Script Provisioner calls into a user-supplier helper, written in a language like Ruby but any language can be used, to generate the per-node configuration properties.\nCertificate Authorities If you have a x509 based Choria deployment (the default) you will need to be able to generate or sign certificates for your nodes. To do this your CA needs to have a API that you can call to issue certificates.\nThere are other options requiring JWT files to be signed also if that is not possible.\nAuthorization Policies In this mode typically nodes do not have any Policies controlling who can invoke Agents and Actions. You will probably want to write a Open Policy Agent policy that the Provisioner will deploy\nMonitoring We expose metrics to Prometheus, for in-depth monitoring you will need Prometheus or a compatible system.\n","description":"","tags":null,"title":"Configuration","uri":"/configuration/index.html"},{"content":"Watching the Provisioning Process Choria Servers publish lifecycle events, these can be viewed using choria tool event --component provision_mode_server.\nServers will publish startup, shutdown and provisioned events that will be shown in the rolling display. These lifecycle events are published in JSON mode on the network and could be stored in a Stream for analysis.\n$ choria tool event --component provision_mode_server Waiting for events from topic choria.lifecycle.event.\u003e on nats://broker.choria.local:4222 14:35:46 [startup] n1.choria.local: provision_mode_server version 0.26.15 14:36:30 [provisioned] n1.choria.local: provision_mode_server 14:36:31 [shutdown] n1.choria.local: provision_mode_server Viewing servers waiting for provisioning One can view the active connections in the Choria Broker, these are nodes waiting to be provisioned. Typically one would also see connections for the Provisioner in addition to these.\n \nLeader Election One can determine the node that is currently the leader in the leader election:\n$ choria election view provisioner Election bucket information for CHORIA_LEADER_ELECTION Created: 01 Jan 01 00:00 +0000 Storage: File Maximum Time: 1m0s Replicas: 3 on hosts broker1*, broker2, broker3 Elections: 7 ╭───────────────────────────────────────────────╮ │ Active Elections │ ├─────────────┬─────────────────────────────────┤ │ Election │ Leader │ ├─────────────┼─────────────────────────────────┤ │ provisioner │ provisioner1.choria.local │ ╰─────────────┴─────────────────────────────────╯ A re-election can be forced using choria election evict provisioner.\nPrometheus Data The Provisioner keep statistics in the Prometheus format, using this you can observe deployed counts, performance of individual RPC calls and more.\n \nAll the statics have a site label allowing you to easily aggregate a global cluster of AAA Services.\n   Statistic Descriptions     choria_provisioner_rpc_time How long each RPC request takes   choria_provisioner_helper_time How long the helper takes to run   choria_provisioner_discovered How many nodes are discovered using the broadcast discovery   choria_provisioner_event_discovered How many nodes were discovered due to events being fired about them   choria_provisioner_discover_cycles How many discovery cycles were ran   choria_provisioner_rpc_errors How many times a RPC request failed   choria_provisioner_helper_errors How many times the helper failed to run   choria_provisioner_discovery_errors How many times the discovery failed to run   choria_provisioner_provision_errors How many times provisioning failed   choria_provisioner_paused 1 when the backplane paused operations, 0 otherwise   choria_provisioner_busy_workers How many workers are busy processing servers   choria_provisioner_provisioned Host many nodes were successfully provisioned    We have a published Grafana Dashboard for this statistics.\n","description":"","tags":null,"title":"Monitoring","uri":"/monitoring/index.html"},{"content":"The Helper is a script or program written in any language that is in charge of handling the steps that are unique to your environment.\nEssentially it receives Server Metadata on its STDIN and writes a response to STDOUT that is used to configure the server.\nSee the sections below for sample Helper scripts.\nInput Let’s look at what you might receive as input on STDIN. The specifics will vary a bit between scenarios which we will call out in specific sections. The data you will get will all already have been validated. For example the JWT would have been parsed already and known to be valid.\n{  \"identity\": \"24bd22cdb279.choria.local\",  \"csr\": null,  \"ed25519_pubkey\": {  \"public_key\": \"2ddc906446a935aefde69ceee2beb3b1d85f264153720d9a752aa88771c0594c\",  \"directory\": \"/etc/choria\",  \"signature\": \"34c5c4d0564747b1d0577ddc9c4084de547235d56e2803a754c76ba4eabbf17e31453ebd9ca4b4a7dd5e25ccf57afd4138519de4666c81d3ee3cd5381cc15a0a\"  },  \"inventory\": \"{\\\"agents\\\":[\\\"choria_provision\\\",\\\"choria_util\\\",\\\"discovery\\\",\\\"rpcutil\\\"],\\\"classes\\\":[],\\\"collectives\\\":[\\\"provisioning\\\"],\\\"data_plugins\\\":[],\\\"facts\\\":{},\\\"machines\\\":[],\\\"main_collective\\\":\\\"provisioning\\\",\\\"version\\\":\\\"0.99.0.20221129\\\",\\\"upgradable\\\":true}\",  \"jwt\": {  \"cht\": \"s3cret\",  \"chs\": false,  \"chu\": \"nats://broker.choria.local:4222\",  \"chpd\": true,  \"extensions\": null,  \"ou\": \"choria\",  \"v2\": true,  \"purpose\": \"choria_provisioning\",  \"iss\": \"Choria Tokens Package v0.26.2\",  \"sub\": \"choria_provisioning\",  \"nbf\": 1669809657,  \"iat\": 1669809657,  \"jti\": \"3a4f9896e013498daeedbcb9a82fcd3c\"  } }    Key Description     identity The Choria Server identity being provisioned - typically FQDN   csr Would be non nil when the pki feature is enabled for obtaining x509 certificates   ed25519_pubkey Would be non nil when the ed25519 feature is enabled   inventory Is the JSON result of choria req rpcutil inventory this lets you find facts, version information and more about the server.   jwt Is the verified contents of the provisioning.jwt on the server when the jwt feature is enabled    Output The response your helper should write to STDOUT is also in JSON format.\nHere is an example that configures Choria Server and uses the jwt feature to enroll a node into an Organization Issuer based network.\n{  \"defer\": false,  \"msg\": \"Done\",  \"certificate\": \"\",  \"ca\": \"\",  \"configuration\": {  \"identity\": \"eb873ce040d7.choria.local\",  \"loglevel\": \"info\",  \"plugin.choria.server.provision\": \"false\",  \"plugin.choria.middleware_hosts\": \"nats://broker.choria.local:4222\",  \"rpcauthorization\": \"0\",  \"plugin.choria.status_file_path\": \"/var/log/choria-status.json\",  \"plugin.choria.submission.spool\": \"/var/lib/choria/submission\",  \"plugin.security.issuer.names\": \"choria\",  \"plugin.security.issuer.choria.public\": \"e72cba5268b34627b75c5ceae9449ad16d62f15f862c30d4e0e7d2588e2e6259\",  \"plugin.security.provider\": \"choria\",  \"plugin.security.choria.token_file\": \"/etc/choria/server.jwt\",  \"plugin.security.choria.seed_file\": \"/etc/choria/server.seed\",  \"plugin.choria.machine.store\": \"/etc/choria/machine\"  },  \"server_claims\": {  \"exp\": 157680000,  \"permissions\": {  \"streams\": true,  \"submission\": true  }  } }   Warning The configuration must set plugin.choria.server.provision to disable provisioning, else the node will keep being reprovisioned forever.\n  Response keys used by scenarios:\n   Key Description     defer Defers the provisioning, this is a soft state meaning the server will come back and be retried later   shutdown Issues a shutdown on the server with exit code 0, systemd will not restart it.   msg A message to log on the Server to explain why it is being deferred or shut down   configuration A JSON Object of configuration items in key-value pairs, will be written to the server config   action_policies A JSON Object of Action Policy policies in key-value pairs, where the key is an agent name   opa_policies A JSON Object of Open Policy Agent policies in key-value pairs, where the key is an agent name or default    When using the pki feature used to enroll with a Certificate Authority:\n   Key Description     key An optional x509 private key that the server should use, will be encrypted using a unique one-time password in transit   certificate The signed certificate in PEM format   ca The Certificate Authority public key in PEM format   ssldir What directory to store the key, certificate and ca in on the server    When using the jwt feature to create server JWT tokens for Organization Issuer based networks:\n   Key Description     server_claims The Choria Server token claims to base the server JWT on    When using the upgrades feature to in-place upgrade servers:\n   Key Description     upgrade The version to upgrade the server to before provisioning    Enrolling nodes with a Certificate Authority Most typically you have a Enterprise Certificate Authority or you made your own using something like cfssl.\nIn this mode Choria Server will generate a private key on its disk, create a CSR and your helper will receive the CSR in PEM format. In your helper you then simply interact with your CA to sign the CSR and respond with the signed Certificate and CA public key. This way once provisioned your server will be fully enrolled for mTLS.\nTo enable the Provisioner to request the CSR the pki feature needs to be enabled in the Provisioner Configuration.\nThe csr input field will then be a JSON Object with:\n   Key Description     csr The PEM encoded CSR the node is sending   public_key The public part of the key the server created   ssldir The directory the server created the private key in so it can be used in the generated configuration    Once you have this data you can use your CA API to enroll the node and get a signed certificate back. Simply put the resulting PEM data in the certificateand ca keys in the reply. You can set a SSL directory but typically just set ssldir to what was received in the input.\n Info A basic sample helper that enrolls in a cfssl based CA can be seen in cfssl-helper.rb\n  In general the Private key stays on the node and you do not need it. Some Certificate Authorities require the private key to be accessible when signing a request. Provisioner support that, if you generate a key in the provisioner and add it to the reply in the key JSON field a single use Shared Secret negotiated using Diffie-Hellman will be used to encrypt the key in transit.\nI would not suggest ever to use a CA that requires you to transmit the Private Key during enrollment, it’s best to assume your CA is unusable at that point and consider a Organization Issuer based deployment.\nEnrolling nodes with an Organization Issuer In cases where a Certificate Authority is not available or it is operated in a way that makes it unsuitable for mTLS use you might opt to deploy Choria in an Organization Issuer based setup. The basic setup of that mode is out of scope for this document.\n Version Hint This applies only to Choria 0.27.0 and newer which is due to ship early 2023\n  To enrol nodes in an Organization Issuer based network you need to enable the ed25519 feature in the Provisioner Configuration.\nOnce enabled the ed25519_pubkey field will hold a JSON Object with these values:\n   Key Description     public_key The ed25519 public key unique to the server   directory The directory that will hold server.seed and where server.jwt will be saved to later   signature A signature of the request made using the private key matching the public_key, this can be ignored as it would already be validated    Once you received these you can include a server_claims in your reply to give the server access to specific features in its JWT claims. The list here is correct for 0.27.0. For an up-to-date list see the Go Documentation for your version of Choria.\nThe claims can include permissions that have these properties.\n   Permission Description     submission Allows the server to use Choria Submission   streams Allows the server to access Choria Streams for example to read KV buckets from autonomous agents   governor Allows the server to access Choria Governor from autonomous agents   service_host Allows the server to host Services    You can also use them to restrict it to a specific sub collective and more. Most values will default to sane defaults when not given.\nUpgrading Servers Choria Server can be upgraded in-place to a new version. This is done by overwriting the binary at run-time with one downloaded from a specifically prepared repository.\nThis can only be done during Provisioning and requires the upgrades feature to be enabled.\n Version Hint This applies only to Choria 0.27.0 and newer which is due to ship early 2023\n  Compatible nodes will have the upgradable key in the inventory received and will be set to true when upgrades are enabled. If you only want to support the latest nodes you can use this to determine if a upgrade is needed along with the version key in the inventory. On nodes that are too old set shutdown or defer.\nYou would have to configure the Provisioner with a repository location and set up a repository on a HTTP server as per the guidelines from go-updater.\nWith all of this in place you can add the upgrade key to the helper response that should just be a desired version like 0.28.0. Provisioner will then attempt to upgrade the node.\n","description":"","tags":null,"title":"Writing a Helper","uri":"/configuration/helper/index.html"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/categories/index.html"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/tags/index.html"}]